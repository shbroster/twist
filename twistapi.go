package twist

import (
	"errors"
	"fmt"
)

// TODO: Document and rationalize the error types.
var (
	// ErrTwist is the base error for all twist errors.
	ErrTwist = errors.New("twist error")

	// ErrInvalidConfig is returned when the TwistConfig is invalid.
	ErrInvalidConfig = fmt.Errorf("%w: invalid config", ErrTwist)

	// ErrInvalidTemplate is returned when creating a new twist with an invalid template.
	ErrInvalidTemplate = fmt.Errorf("%w: invalid template", ErrTwist)

	// ErrInvalidData is returned when attemping to execute or parse a template with invalid data.
	ErrInvalidData = fmt.Errorf("%w: invalid data", ErrTwist)

	// ErrTemplateMismatch is returned when parsing a string which does not match the original template.
	ErrTemplateMismatch = fmt.Errorf("%w: template mismatch", ErrTwist)

	// ErrAmbiguousTemplate is returned when attempting to get a unique data set from a template
	// which has multiple possible data sets.
	ErrAmbiguousTemplate = fmt.Errorf("%w: template is ambiguous", ErrTwist)
)

type TwistConfig struct {
	Delimiters [2]string
}

type TwistOption func(*TwistConfig) error

func WithDelimiters(delimiters [2]string) TwistOption {
	return func(c *TwistConfig) error {
		if delimiters[0] == delimiters[1] {
			return fmt.Errorf("delimeters must not match: %w", ErrInvalidConfig)
		}
		if len(delimiters[0]) < 1 || len(delimiters[1]) < 1 {
			return fmt.Errorf("delimeters must not be empty: %w", ErrInvalidConfig)
		}
		c.Delimiters = delimiters
		return nil
	}
}

// New creates a 'twist' and errors if the template is invald.
//
// Twists are reversable templates that can be used to create basic string template
// using {{ and }} as delimeters by default.
func New(s string, opts ...TwistOption) (twist, error) {
	config := TwistConfig{Delimiters: [2]string{"{{", "}}"}}
	for _, opt := range opts {
		if err := opt(&config); err != nil {
			return twist{}, err
		}
	}

	result, err := extractFields(s, config.Delimiters)
	if err != nil {
		return twist{}, err
	}
	return twist{
		original:     s,
		fieldParts:   result[0],
		pretextParts: result[1],
	}, nil
}

// MustNew is a convenience function that wraps New and panics if the template is invalid.
func MustNew(s string, opts ...TwistOption) twist {
	result, err := New(s, opts...)
	if err != nil {
		panic(err)
	}
	return result
}

type executeConfig struct {
	ForceUnique bool
}

type ExecuteOption func(*executeConfig)

func WithUnique() ExecuteOption {
	return func(o *executeConfig) {
		o.ForceUnique = true
	}
}

// Execute executes the template with the given data and returns the generated string.
func (t twist) Execute(data any, opts ...ExecuteOption) (string, error) {
	config := executeConfig{
		ForceUnique: false,
	}
	for _, opt := range opts {
		opt(&config)
	}

	result, err := t.execute(data)
	if err != nil {
		return "", err
	}

	if config.ForceUnique {
		indicies, err := t.findFieldIndicies(result)
		if err != nil {
			panic(err)
		}
		if len(indicies) != 1 {
			return "", fmt.Errorf("multiple matches: %w", ErrAmbiguousTemplate)
		}
	}
	return result, nil
}

// ParseToMap takes a string generated by executing a template and returns the unique
// set of data that was used to generate the given string from the template.
//
// If there is not a unique set of data then this function errors. The ParseToMaps function
// can be used to get all possible data sets.
func (t twist) ParseToMap(s string) (map[string]string, error) {
	indicies, err := t.findFieldIndicies(s)
	if err != nil {
		return nil, err
	}

	if len(indicies) != 1 {
		return nil, fmt.Errorf("multiple matches: %w", ErrAmbiguousTemplate)
	}

	result := map[string]string{}
	for i, field := range t.fields() {
		result[field] = s[indicies[0][i][0]:indicies[0][i][1]]
	}
	return result, nil
}

// ParseToMaps takes a string generated by executing a template and returns all
// possible data sets could have generatd string from the given template.
func (t twist) ParseToMaps(s string) ([]map[string]string, error) {
	allIndicies, err := t.findFieldIndicies(s)
	if err != nil {
		return nil, err
	}

	result := make([]map[string]string, len(allIndicies))
	for i := range result {
		result[i] = make(map[string]string)
	}
	for i, field := range t.fields() {
		for j, indicies := range allIndicies {
			result[j][field] = s[indicies[i][0]:indicies[i][1]]
		}
	}
	return result, nil
}

// Parse takes a string generated by executing a template and returns the original data
// that was used when executing the template.
//
// The parsed data is cast to the appropriate type and stored in the provided struct.
//
// If the provided string could have been generated using multipe different data sets
// then this function errors. The ParseToMaps function  can be used to get all possible data
// sets.
func (t twist) Parse(s string, out any) error {
	result, err := t.ParseToMap(s)
	if err != nil {
		return err
	}
	return decode(result, out)
}
