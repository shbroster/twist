package twist

import (
	"errors"
	"fmt"
)

var (
	ErrInvalidTemplate   = errors.New("invalid template")
	ErrInvalidField      = errors.New("invalid field")
	ErrInvalidData       = errors.New("invalid data")
	ErrInvalidArgument   = errors.New("invalid argument")
	ErrTemplateMismatch  = errors.New("template mismatch")
	ErrAmbiguousTemplate = errors.New("template is ambiguous")
)

// New creates a 'twist', errors if the template is invald.
//
// Twists are reversable templates that can be used to create basic string template
// using {{ and }} as delimeters.
func New(s string) (twist, error) {
	result, err := extractFields(s)
	if err != nil {
		return twist{}, err
	}
	return twist{
		original:     s,
		fieldParts:   result[0],
		pretextParts: result[1],
	}, nil
}

// Execute executes the template with the given data and returns the generated string.
func (t twist) Execute(data any) (string, error) {
	return t.execute(data)
}

// ParseToMap takes a string generated by executing a template and returns the unique
// set of data that was used to generate the given string from the template.
//
// If there is not a unique set of data then this function errors. The ParseToMaps function
// can be used to get all possible data sets.
func (t twist) ParseToMap(s string) (map[string]string, error) {
	indicies, err := t.findFieldIndicies(s)
	if err != nil {
		return nil, err
	}

	if len(indicies) != 1 {
		return nil, fmt.Errorf("multiple matches: %w", ErrAmbiguousTemplate)
	}

	result := map[string]string{}
	for i, field := range t.fields() {
		result[field] = s[indicies[0][i][0]:indicies[0][i][1]]
	}
	return result, nil
}

// ParseToMaps takes a string generated by executing a template and returns all
// possible data sets could have generatd string from the given template.
func (t twist) ParseToMaps(s string) ([]map[string]string, error) {
	allIndicies, err := t.findFieldIndicies(s)
	if err != nil {
		return nil, err
	}

	result := []map[string]string{}
	for i, field := range t.fields() {
		for j, indicies := range allIndicies {
			result[j][field] = s[indicies[i][0]:indicies[i][1]]
		}
	}
	return result, nil
}

// Parse takes a string generated by executing a template and returns the original data
// that was used when executing the template.
//
// The parsed data is cast to the appropriate type and stored in the provided struct.
//
// If the provided string could have been generated using multipe different data sets
// then this function errors. The ParseToMaps function  can be used to get all possible data
// sets.
func (t twist) Parse(s string, out any) error {
	result, err := t.ParseToMap(s)
	if err != nil {
		return err
	}
	return decode(result, out)
}
