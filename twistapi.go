package twist

import (
	"errors"
	"fmt"
)

var (
	// ErrTwist is the base error for all twist errors.
	ErrTwist = errors.New("twist error")

	// ErrInvalidConfig is returned when the TwistConfig is invalid.
	ErrInvalidConfig = fmt.Errorf("%w: invalid config", ErrTwist)

	// ErrInvalidTemplate is returned when creating a new twist with an invalid template.
	ErrInvalidTemplate = fmt.Errorf("%w: invalid template", ErrTwist)

	// ErrInvalidData is returned when attemping to execute or parse a template with invalid data.
	ErrInvalidData = fmt.Errorf("%w: invalid data", ErrTwist)

	// ErrTemplateMismatch is returned when parsing a string which does not match the original template.
	ErrTemplateMismatch = fmt.Errorf("%w: template mismatch", ErrTwist)

	// ErrAmbiguousTemplate is returned when attempting to get a unique data set from a template
	// which has multiple possible data sets.
	ErrAmbiguousTemplate = fmt.Errorf("%w: template is ambiguous", ErrTwist)
)

type twistConfig struct {
	Delimiters [2]string
}

type twistOption func(*twistConfig) error

// When creating a 'twist' with `New` this function creates a twist with a custom
// set of delimeters, by default '{{' and '}}' are used as delimeters.
func WithDelimiters(delimiters [2]string) twistOption {
	return func(c *twistConfig) error {
		if delimiters[0] == delimiters[1] {
			return fmt.Errorf("delimeters must not match: %w", ErrInvalidConfig)
		}
		if len(delimiters[0]) < 1 || len(delimiters[1]) < 1 {
			return fmt.Errorf("delimeters must not be empty: %w", ErrInvalidConfig)
		}
		c.Delimiters = delimiters
		return nil
	}
}

// New creates a 'twist' and errors if the template is invald.
//
// Twists are reversible templates that can be used to create basic string template
// using {{ and }} as delimeters by default.
func New(s string, opts ...twistOption) (Twist, error) {
	config := twistConfig{Delimiters: [2]string{"{{", "}}"}}
	for _, opt := range opts {
		if err := opt(&config); err != nil {
			return Twist{}, err
		}
	}

	result, err := extractFields(s, config.Delimiters)
	if err != nil {
		return Twist{}, err
	}
	return Twist{
		original:     s,
		fieldParts:   result[0],
		pretextParts: result[1],
	}, nil
}

// MustNew is a convenience function that wraps `New` and panics if the template is invalid.
func MustNew(s string, opts ...twistOption) Twist {
	result, err := New(s, opts...)
	if err != nil {
		panic(err)
	}
	return result
}

type executeConfig struct {
	ForceUnique bool
}

type executeOption func(*executeConfig)

// When `Executing` a template this option causes an error to be returned if the
// resulting string cannot be used to recreate the original data passed into the
// template.
func WithUnique() executeOption {
	return func(o *executeConfig) {
		o.ForceUnique = true
	}
}

// Execute executes the template with the given data and returns the generated string.
func (t Twist) Execute(data any, opts ...executeOption) (string, error) {
	config := executeConfig{
		ForceUnique: false,
	}
	for _, opt := range opts {
		opt(&config)
	}

	result, err := t.execute(data)
	if err != nil {
		return "", err
	}

	if config.ForceUnique {
		ch := t.findFieldIndicies(result)
		chRes, ok := <-ch

		if !ok || chRes.err != nil {
			return "", fmt.Errorf("unable to parse resulting string: %w", ErrInvalidData)
		}
		chRes, ok = <-ch
		if ok {
			return "", fmt.Errorf("multiple mathces: %w", ErrAmbiguousTemplate)
		}

	}
	return result, nil
}

// MustExecute is a convenience function that wraps `Execute` and panics if it returns an error.
func (t Twist) MustExecute(data any, opts ...executeOption) string {
	val, err := t.Execute(data, opts...)
	if err != nil {
		panic(err)
	}
	return val
}

// ParseToMap takes a string generated by executing a template and returns the unique
// set of data that was used to generate the given string from the template.
//
// If there is not a unique set of data then this function errors. The ParseToMaps function
// can be used to get all possible data sets.
func (t Twist) ParseToMap(s string) (map[string]string, error) {
	resultMap := map[string]string{}

	ch := t.findFieldIndicies(s)
	result, ok := <-ch
	if !ok {
		panic("Unexpected error; channel closed parsing string in ParseToMap")
	}
	if result.err != nil {
		return nil, result.err
	}
	_, ok = <-ch
	if ok {
		return nil, fmt.Errorf("multiple matches: %w", ErrAmbiguousTemplate)
	}

	for i, field := range t.fields() {
		resultMap[field] = s[result.val[i][0]:result.val[i][1]]
	}
	return resultMap, nil
}

// ParseToMaps takes a string generated by executing a template and returns all
// possible data sets could have generatd string from the given template.
func (t Twist) ParseToMaps(s string) ([]map[string]string, error) {
	ch := t.findFieldIndicies(s)
	var resultMaps []map[string]string
	for result := range ch {
		if result.err != nil {
			return nil, result.err
		}
		resultMap := make(map[string]string)
		for i, field := range t.fields() {
			resultMap[field] = s[result.val[i][0]:result.val[i][1]]
		}
		resultMaps = append(resultMaps, resultMap)

	}
	return resultMaps, nil
}

// Parse takes a string generated by executing a template and returns the original data
// that was used when executing the template.
//
// The parsed data is cast to the appropriate type and stored in the provided struct.
//
// If the provided string could have been generated using multiple different data sets
// then this function errors. The ParseToMaps function  can be used to get all possible data
// sets.
func (t Twist) Parse(s string, out any) error {
	result, err := t.ParseToMap(s)
	if err != nil {
		return err
	}
	return decode(result, out)
}
